@startuml

' ============================================================================
' PRESENTAION LAYER
' ============================================================================

package Presentation {
    class LinterManager {
        - checkBoxPanel: JPanel
        - checkBoxes: List<JCheckBox>
        - outputArea: JTextArea
        - statusLabel: JLabel
        - selectFilesButton: JButton
        - selectPackageButton: JButton
        - runLintButton: JButton
        - selectedFiles: List<File>

        + LinterManager()
        + {static} main(String[] args): void
        - initializeUI(): void
        - createFileSelectionPanel(): JPanel
        - createCheckSelectionPanel(): JPanel
        - createOutputPanel(): JPanel
        - createBottomPanel(): JPanel
        - loadAvailableChecks(): void
        - loadChecksFromPackage(packageName: String, interfaceType: Class<?>, category: Category): List<CheckWrapper>
        - selectClassFiles(): void
        - selectPackageDirectory(): void
        - collectClassFiles(directory: File, fileList: List<File>): void
        - clearSelection(): void
        - updateFileSelectionStatus(): void
        - selectByCategory(): void
        - runLinter(): void
        - getSelectedChecks(): List<CheckWrapper>
        - loadClassNode(classFile: File): ClassNode
    }

    class CheckWrapper {
        check: ICheck;
        category: Category;
        + CheckWrapper(check: ICheck, category: Category)
        + toString(): String
    }
}

' ============================================================================
' DOMAIN LAYER
' ============================================================================
package Domain {
    interface ICheck {
      + execute(classNode: ClassNode): List<LintResult>}
      + getName(): String
    }

    ' ============================================================================
    ' PATTERN CHECKS (A)
    ' ============================================================================

    interface IPatternCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class DecoratorPatternCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      -isLikelyDecorator(ClassNode classNode) : boolean
      -checkDecoratorQuality(ClassNode classNode, List<LintResult> lintResults) : void
      -findComponentFields(ClassNode classNode) : List<FieldNode>
      -isFieldUsedInMethods(ClassNode classnode, String fieldname) : boolean
      -isFieldDelegatedTo(ClassNode classnode, String fieldname) : boolean
      -checkUnusedConstructorParameters(ClassNode classNode, Set<String> expectedComponentTypes, List<LintResult> lr) : void
      -isParameterStoredInField(MethodNode constructor, List<FieldNode> fields) : boolean
      -extractParameterTypes(String descriptor) : List<String>
      -getSimpleClassName(String fullClassName) : String
      -isStatic(FieldNode field) : boolean
      -isPrimitive(String descriptor) : boolean
      -extractClassName(String descriptor) : String
      -isRelatedType(String type1, String type2) : boolean

    }

    class RedundantInterfaceCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class StrategyPatternCheck {
      - {static} MIN_CONDITIONAL_BRANCHES: int = 3
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      - userStrategyPattern(classNode: ClassNode): boolean
      - countConditionalBranches(methodNode: MethodNode): int
      - isConditionalJump(int opcode): boolean
      - isConstructor(method: MethodNode): boolean
      - getLineNumber(method: MethodNode): int
      - getSimpleClassName(internalName: String): String
    }

    class ThreeLayerPatternCheck {
      - analyzedClasses: Map<String, ClassInfo>

      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      - findClassesDirectory(ClassNode): String
      - evaluatePattern(List<Reference>): void
      - checkLayerViolation(ClassInfo, ClassInfo): String
      - getReferences(ClassNode): List<References>
      - analyzeClass(Path): void
      - analyzeClassNode(classNode): void
      - extractNameFromDescriptor(String): String
      - determineLayer(String): Layer

    }

    class ClassInfo{
        name: String
        layer: Layer
        node: ClassNode
        superClasses: List<String>
        methods: List<MethodNode>
        vars: List<ClassInfo>
        + ClassInfo(String, Layer)
        + addVar(ClassInfo): void
    }

    enum Layer{
    PRESENTATION,
    DOMAIN,
    DATA,
    UNKNOWN
    }

    class Reference{
     - sourceClass: ClassInfo
     - targetClass: ClassInfo
     - source: String
     + Reference(ClassInfo, ClassInfo, String)
    }
    ' ============================================================================
    ' PRINCIPLE CHECKS (B)
    ' ============================================================================

    interface IPrincipleCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class InvalidHashCodeOrEqualsCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class HollywoodPrincipleCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class CodeDuplicationCheck {
      - {static} SIMILARITY_THRESHOLD: double = 0.8
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      - calculateSimilarity(method1: MethodNode, method2: MethodNode): double
      - getOpcodeSequence(method: MethodNode): List<Integer>
      - longestCommonSubsequence(seq1: List<Integer>, seq2: List<Integer>): int
      - isConstructor(method: MethodNode): boolean
      - isMethodTooSmall(method: MethodNode): boolean
      - getLineNumber(method: MethodNode): int
    }

    class EncapsulationCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    ' ============================================================================
    ' STYLE CHECKS (C)
    ' ============================================================================

    interface IStyleCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class GlobalVariableCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      -iStatic(FieldNode field) : boolean
      -isFinal(FieldNode field) : boolean
      -isPublic(FieldNode field) : boolean
      -isPrivate(FieldNode field) : boolean
      -checkGlobalVariableConventions(FieldNode field, List<LintResult> lintResults, String className) : void
      -checkConstantNaming(FieldNode field, String fieldName, List<LintResult> lintResults, String classname) : void
      -checkStaticVariableNaming(FieldNode field, String fieldName, Lint<LintResult> lintResults, String classname) : void
      -isUpperSnakeCase(String name) : boolean
      -isCamelCase(String name) : boolean
    }

    class CamelCaseCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class UnusedVariablesCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      - isFieldUsed(field: FieldNode, classNode: ClassNode): boolean
    }

    class SpellCheck {
      - langTool: JLanguageTool
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      - checkWord(String, AbstractInsnNode): List<LintResult>
      - checkWord(String, String): List<LintResult>
      - ensureLangTool(): boolean
      - getLineNumber(AbstractInsnNode): int
      - getWords(String): List<String>
    }

    class MissingAbstractImplCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      -checkAbstractMethodImplementations(ClassNode classNode, ClassNode superClass, List<LintResult> lintResults) : void
      -collectAbstractMethods(ClassNode classNode) : Set<MethodSignature>
      -collectImplementedMethods(ClassNode classNode) : Set<MethodSignature>
      -collectInheritedConcreteMethods(String className) : Set<MethodSignature>
      -loadClass(String className) : ClassNode
      -isAbstract(ClassNode classNode) : boolean
      -isInterface(ClassNode classNode) : boolean
      -isAbstractMethod(MethodeNode method) : boolean
      -isPrivate(MethodNode method) : boolean
      -getSimpleClassName(String fullClassName) : String
    }
    class MethodSignature{
        -name : String
        -descriptor : String
        -MethodSignature(String name, String descriptior)
        +equal(Object obj) : boolean
        +hashCode() : int
        +toString() : String
    }


    class UnusedParametersCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class DataTypeCompatibilityCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      - checkFieldAssignments(classNode: ClassNode, lintResults: List<LintResult>): void
      - checkMethods(classNode: ClassNode, lintResults: List<LintResult>): void
      - findField(classNode: ClassNode, name: String): FieldNode
      - findMethod(classNode: ClassNode, name: String, desc: String): MethodNode
      - isReturnInstruction(insn: AbstractIsnsNode): boolean
      - isCorrectReturnInstruction(opcode: int, returnType: Type): boolean
      - getLineNumber(insn: AbstractInsnNode): int
    }

    class SwallowedExceptionCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      -checkMethodFroSwallowedException(className: String, method: MethodNode): List<LintResult>
      - countMeaningfulInstructions(InsnList, int, int): int
      - isNopOrComment(AbstracctInsnNode): boolean
      - getLineNumber(AbstractInsnNode): int
    }

    ' ============================================================================
    ' RESULTS
    ' ============================================================================

    class LintResult {
      - checkName: String
      - category: Category
      - location: String
      - message: String
      + toString(): String
    }

    enum Category {
      PATTERN
      PRINCIPLE
      STYLE
    }

    ' ===========================================================================
    ' NOTES
    ' ===========================================================================
    note right of IPatternCheck
    <b>Pattern Detection (A)</b>
      Mason: Decorator Pattern
      Rishi: Redundant Interface
      PJ: Strategy Pattern
      Sandya: Three Layer Pattern
    end note

    note right of IPrincipleCheck
    <b>Principle  (B)</b>
      Mason: Open/Closed
      Rishi: Hollywood Principle
      PJ: Code Duplication
      Sandya: Encapsulation
    end note

    note right of IStyleCheck
    <b>Style Checks (C)</b>
      Mason: Global Variables
      Rishi: Camel Case
      PJ: Unused Variables
      Sandya: Spell Check

    <b>Advanced Checks (4)</b>
      Mason: Missing Abstract Impl
      Rishi: Unused Parameters
      PJ: Data Type Compatibility
      Sandya: Swallowed Exception
    end note
}


' ============================================================================
' RELATIONSHIPS
' ============================================================================
LinterManager .u.>"*" ICheck
LinterManager --> "*" CheckWrapper

IPatternCheck -u-|> ICheck
IPrincipleCheck -u-|> ICheck
IStyleCheck -u-|> ICheck

LintResult -r-> Category
ICheck .r.> LintResult

DecoratorPatternCheck ..|> IPatternCheck
RedundantInterfaceCheck ..|> IPatternCheck
StrategyPatternCheck ..|> IPatternCheck
ThreeLayerPatternCheck ..|> IPatternCheck

InvalidHashCodeOrEqualsCheck ..|> IPrincipleCheck
HollywoodPrincipleCheck ..|> IPrincipleCheck
CodeDuplicationCheck ..|> IPrincipleCheck
EncapsulationCheck ..|> IPrincipleCheck

GlobalVariableCheck ..|> IStyleCheck
CamelCaseCheck ..|> IStyleCheck
UnusedVariablesCheck ..|> IStyleCheck
SpellCheck ..|> IStyleCheck

MissingAbstractImplCheck ..|> IStyleCheck
UnusedParametersCheck ..|> IStyleCheck
DataTypeCompatibilityCheck ..|> IStyleCheck
SwallowedExceptionCheck ..|> IStyleCheck

ThreeLayerPatternCheck --> ClassInfo
ThreeLayerPatternCheck ...> Reference
ClassInfo --> Layer
ThreeLayerPatternCheck...> Layer
MissingAbstractImplCheck -u-> MethodSignature


' ============================================================================
' LAYOUT HINTS
' ============================================================================

IPatternCheck -[hidden]down- DecoratorPatternCheck
IPatternCheck -[hidden]down- RedundantInterfaceCheck
IPatternCheck -[hidden]down- StrategyPatternCheck
IPatternCheck -[hidden]down- ThreeLayerPatternCheck

IPrincipleCheck -[hidden]down- InvalidHashCodeOrEqualsCheck
IPrincipleCheck -[hidden]down- HollywoodPrincipleCheck
IPrincipleCheck -[hidden]down- CodeDuplicationCheck
IPrincipleCheck -[hidden]down- EncapsulationCheck

IStyleCheck -[hidden]down- GlobalVariableCheck
IStyleCheck -[hidden]down- CamelCaseCheck
IStyleCheck -[hidden]down- UnusedVariablesCheck
IStyleCheck -[hidden]down- SpellCheck

@enduml