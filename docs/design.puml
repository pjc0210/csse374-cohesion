@startuml

' ============================================================================
' PRESENTAION LAYER
' ============================================================================

package Presentation {
    class LinterUI extends JFrame{
      - frame: JFrame

      + main(args: String[]): void
    }
}

' ============================================================================
' DOMAIN LAYER
' ============================================================================
package Domain {
    class LinterManager {
        - allPatterns: List<IPatternCheck>
        - allPrinciples: List<IPrincipleCheck>
        - allStyles: List<IStyleCheck>


    }

    class Linter {
      + {static} fieldForAnalysisByThisProgram: String[]
      - appliedPatterns: List<IPatternCheck>
      - appliedPrinciples: List<IPrincipleCheck>
      - appliedStyles: List<IStyleCheck>
      
      + {static} main(args: String[]): void
      - {static} printClass(classNode: ClassNode): void
      - {static} printFields(classNode: ClassNode): void
      - {static} printMethods(classNode: ClassNode): void
      - {static} printInstructions(methodNode: MethodNode): void
    }

    interface ICheck {
      + execute(classNode: ClassNode): List<LintResult>}
      + getName(): String
    }

    ' ============================================================================
    ' PATTERN CHECKS (A)
    ' ============================================================================

    interface IPatternCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class DecoratorPatternCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      -isLikelyDecorator(ClassNode classNode) : boolean
      -checkDecoratorQuality(ClassNode classNode, List<LintResult> lintResults) : void
      -findComponentFields(ClassNode classNode) : List<FieldNode>
      -isFieldUsedInMethods(ClassNode classnode, String fieldname) : boolean
      -isFieldDelegatedTo(ClassNode classnode, String fieldname) : boolean
      -checkUnusedConstructorParameters(ClassNode classNode, Set<String> expectedComponentTypes, List<LintResult> lr) : void
      -isParameterStoredInField(MethodNode constructor, List<FieldNode> fields) : boolean
      -extractParameterTypes(String descriptor) : List<String>
      -getSimpleClassName(String fullClassName) : String
      -isStatic(FieldNode field) : boolean
      -isPrimitive(String descriptor) : boolean
      -extractClassName(String descriptor) : String
      -isRelatedType(String type1, String type2) : boolean

    }

    class RedundantInterfaceCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class StrategyPatternCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class ThreeLayerPatternCheck {
      - analyzedClasses: Map<String, ClassInfo>

      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      - findClassesDirectory(ClassNode): String
      - evaluatePattern(List<Reference>): void
      - checkLayerViolation(ClassInfo, ClassInfo): String
      - getReferences(ClassNode): List<References>
      - analyzeClass(Path): void
      - analyzeClassNode(classNode): void
      - extractNameFromDescriptor(String): String
      - determineLayer(String): Layer

    }

    class ClassInfo{
        name: String
        layer: Layer
        node: ClassNode
        superClasses: List<String>
        methods: List<MethodNode>
        vars: List<ClassInfo>
        + ClassInfo(String, Layer)
        + addVar(ClassInfo): void
    }

    enum Layer{
    PRESENTATION,
    DOMAIN,
    DATA,
    UNKNOWN
    }

    class Reference{
     - sourceClass: ClassInfo
     - targetClass: ClassInfo
     - source: String
     + Reference(ClassInfo, ClassInfo, String)
    }
    ' ============================================================================
    ' PRINCIPLE CHECKS (B)
    ' ============================================================================

    interface IPrincipleCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class InvalidHashCodeOrEqualsCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class HollywoodPrincipleCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class CodeDuplicationCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class EncapsulationCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    ' ============================================================================
    ' STYLE CHECKS (C)
    ' ============================================================================

    interface IStyleCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class GlobalVariableCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      -iStatic(FieldNode field) : boolean
      -isFinal(FieldNode field) : boolean
      -isPublic(FieldNode field) : boolean
      -isPrivate(FieldNode field) : boolean
      -checkGlobalVariableConventions(FieldNode field, List<LintResult> lintResults, String className) : void
      -checkConstantNaming(FieldNode field, String fieldName, List<LintResult> lintResults, String classname) : void
      -checkStaticVariableNaming(FieldNode field, String fieldName, Lint<LintResult> lintResults, String classname) : void
      -isUpperSnakeCase(String name) : boolean
      -isCamelCase(String name) : boolean
    }

    class CamelCaseCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class UnusedVariablesCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class SpellCheck {
      - langTool: JLanguageTool
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      - checkWord(String, AbstractInsnNode): List<LintResult>
      - checkWord(String, String): List<LintResult>
      - ensureLangTool(): boolean
      - getLineNumber(AbstractInsnNode): int
      - getWords(String): List<String>
    }

    class MissingAbstractImplCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      -checkAbstractMethodImplementations(ClassNode classNode, ClassNode superClass, List<LintResult> lintResults) : void
      -collectAbstractMethods(ClassNode classNode) : Set<MethodSignature>
      -collectImplementedMethods(ClassNode classNode) : Set<MethodSignature>
      -collectInheritedConcreteMethods(String className) : Set<MethodSignature>
      -loadClass(String className) : ClassNode
      -isAbstract(ClassNode classNode) : boolean
      -isInterface(ClassNode classNode) : boolean
      -isAbstractMethod(MethodeNode method) : boolean
      -isPrivate(MethodNode method) : boolean
      -getSimpleClassName(String fullClassName) : String
    }
    class MethodSignature{
        -name : String
        -descriptor : String
        -MethodSignature(String name, String descriptior)
        +equal(Object obj) : boolean
        +hashCode() : int
        +toString() : String
    }


    class UnusedParametersCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class DataTypeCompatibilityCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
    }

    class SwallowedExceptionCheck {
      + execute(classNode: ClassNode): List<LintResult>
      + getName(): String
      -checkMethodFroSwallowedException(className: String, method: MethodNode): List<LintResult>
      - countMeaningfulInstructions(InsnList, int, int): int
      - isNopOrComment(AbstracctInsnNode): boolean
      - getLineNumber(AbstractInsnNode): int
    }

    ' ============================================================================
    ' RESULTS
    ' ============================================================================

    class LintResult {
      - checkName: String
      - category: Category
      - location: String
      - message: String
      + toString(): String
    }

    enum Category {
      PATTERN
      PRINCIPLE
      STYLE
    }

    ' ===========================================================================
    ' NOTES
    ' ===========================================================================
    note right of IPatternCheck
    <b>Pattern Detection (A)</b>
      Mason: Decorator Pattern
      Rishi: Redundant Interface
      PJ: Strategy Pattern
      Sandya: Three Layer Pattern
    end note

    note right of IPrincipleCheck
    <b>Principle  (B)</b>
      Mason: Open/Closed
      Rishi: Hollywood Principle
      PJ: Code Duplication
      Sandya: Encapsulation
    end note

    note right of IStyleCheck
    <b>Style Checks (C)</b>
      Mason: Global Variables
      Rishi: Camel Case
      PJ: Unused Variables
      Sandya: Spell Check

    <b>Advanced Checks (4)</b>
      Mason: Missing Abstract Impl
      Rishi: Unused Parameters
      PJ: Data Type Compatibility
      Sandya: Swallowed Exception
    end note
}


' ============================================================================
' RELATIONSHIPS
' ============================================================================
Linter -->"*" ICheck

IPatternCheck -u-|> ICheck
IPrincipleCheck -u-|> ICheck
IStyleCheck -u-|> ICheck

LintResult -r-> Category
ICheck .r.> LintResult

DecoratorPatternCheck ..|> IPatternCheck
RedundantInterfaceCheck ..|> IPatternCheck
StrategyPatternCheck ..|> IPatternCheck
ThreeLayerPatternCheck ..|> IPatternCheck

InvalidHashCodeOrEqualsCheck ..|> IPrincipleCheck
HollywoodPrincipleCheck ..|> IPrincipleCheck
CodeDuplicationCheck ..|> IPrincipleCheck
EncapsulationCheck ..|> IPrincipleCheck

GlobalVariableCheck ..|> IStyleCheck
CamelCaseCheck ..|> IStyleCheck
UnusedVariablesCheck ..|> IStyleCheck
SpellCheck ..|> IStyleCheck

MissingAbstractImplCheck ..|> IStyleCheck
UnusedParametersCheck ..|> IStyleCheck
DataTypeCompatibilityCheck ..|> IStyleCheck
SwallowedExceptionCheck ..|> IStyleCheck

ThreeLayerPatternCheck --> ClassInfo
ThreeLayerPatternCheck ...> Reference
ClassInfo --> Layer
ThreeLayerPatternCheck...> Layer
MissingAbstractImplCheck -> MethodSignature


' ============================================================================
' LAYOUT HINTS
' ============================================================================

IPatternCheck -[hidden]down- DecoratorPatternCheck
IPatternCheck -[hidden]down- RedundantInterfaceCheck
IPatternCheck -[hidden]down- StrategyPatternCheck
IPatternCheck -[hidden]down- ThreeLayerPatternCheck

IPrincipleCheck -[hidden]down- InvalidHashCodeOrEqualsCheck
IPrincipleCheck -[hidden]down- HollywoodPrincipleCheck
IPrincipleCheck -[hidden]down- CodeDuplicationCheck
IPrincipleCheck -[hidden]down- EncapsulationCheck

IStyleCheck -[hidden]down- GlobalVariableCheck
IStyleCheck -[hidden]down- CamelCaseCheck
IStyleCheck -[hidden]down- UnusedVariablesCheck
IStyleCheck -[hidden]down- SpellCheck

@enduml